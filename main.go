// Command runx is an hk plugin to run a command on Heroku.
// It's like heroku run, but doesn't use the rendezvous
// service, instead using a standard HTTP router, webx.
package main

import (
	"bytes"
	"code.google.com/p/go.crypto/ssh"
	"code.google.com/p/go.net/websocket"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"syscall"
	"time"
)

const Timeout = 20 * time.Second

const script = `
echo start;
set -e;
curl -so /tmp/runxd https://frozen-citadel-4101.herokuapp.com/bin/runxd
chmod +x /tmp/runxd;
echo ready;
exec /tmp/runxd;
`

func main() {
	log.SetFlags(0)
	maybePrintInfo()
	maybeProxy()
	args := os.Args[1:]
	runxURL, err := getToken()
	if err != nil {
		log.Fatal(err)
	}
	if len(args) > 0 && args[0] == "-d" {
		args = args[1:]
		_, err := herokuRun(strings.Join(args, " "), nil)
		if err != nil {
			log.Fatal(err)
		}
		return
	}
	key, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		log.Fatal("keygen", err)
	}
	pub, err := ssh.NewPublicKey(&key.PublicKey)
	if err != nil {
		log.Fatal(err)
	}
	uuid, err := herokuRun(script, map[string]string{
		"RUNX_URL":        runxURL,
		"AUTHORIZED_KEYS": string(ssh.MarshalAuthorizedKey(pub)),
	})
	if err != nil {
		log.Fatal(err)
	}
	log.Fatal(execSSH(runxURL, uuid, key, args))
}

// Uses hk api to send a ps run request.
func herokuRun(cmd string, env map[string]string) (uuid string, err error) {
	// as far as the platform is concerned,
	// the dyno is always detached.
	params := map[string]interface{}{"command": cmd}
	if env != nil {
		params["env"] = env
	}
	b, err := json.Marshal(params)
	if err != nil {
		return "", err
	}
	apiURL := strings.TrimRight(os.Getenv("HEROKU_API_URL"), "/")
	app := os.Getenv("HKAPP")
	req, err := http.NewRequest("POST", apiURL+"/apps/"+app+"/dynos", bytes.NewReader(b))
	if err != nil {
		return "", err
	}
	req.SetBasicAuth(os.Getenv("HKUSER"), os.Getenv("HKPASS"))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/vnd.heroku+json; version=3")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 201 {
		return "", fmt.Errorf("run: unexpected http status: %s", resp.Status)
	}
	var info struct{ Id string }
	err = json.NewDecoder(resp.Body).Decode(&info)
	return info.Id, err
}

func execSSH(url, uuid string, key *rsa.PrivateKey, args []string) error {
	f, err := ioutil.TempFile("", "runx")
	if err != nil {
		return fmt.Errorf("tmpfile: %s", err)
	}
	defer f.Close()
	var b pem.Block
	b.Type = "RSA PRIVATE KEY"
	b.Bytes = x509.MarshalPKCS1PrivateKey(key)
	if err = pem.Encode(f, &b); err != nil {
		return fmt.Errorf("pem: %s", err)
	}
	f.Seek(0, 0)
	argv := []string{
		"ssh",
		"-i" + f.Name(),
		"-oProxyCommand=hk runx [proxy]",
		"-oLocalCommand=rm " + f.Name(),
		"-oStrictHostKeyChecking=no",
		"-oUserKnownHostsFile=/dev/null",
		"dyno@" + uuid,
	}
	env := append(os.Environ(), "RUNX_URL="+url)
	return syscall.Exec("/usr/bin/ssh", append(argv, args...), env)
}

// getToken returns a rendezvous token from the webx api.
// It's like provisioning a normal addon resource, except:
//   - no privileges are necessary; anyone can get one
//   - the name is generated by the webx api
//   - webx keeps no persistent state (e.g. custom domains)
func getToken() (string, error) {
	resp, err := http.Get("https://api.webx.io/rendezvous-token")
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 201 {
		return "", fmt.Errorf("token: unexpected http status: %s", resp.Status)
	}
	b, err := ioutil.ReadAll(resp.Body)
	return string(b), err
}

func maybeProxy() {
	urlStr := os.Getenv("RUNX_URL")
	if urlStr == "" {
		return
	}
	log.SetPrefix("runx [proxy]: ")
	defer os.Exit(0)
	urlStr = strings.TrimRight("ws:"+urlStr[6:], "/") + "/sshd"
	u, err := url.Parse(urlStr)
	if err != nil {
		log.Fatal(err)
	}
	addr := u.Host + ":80"
	name := u.User.Username()
	u.User = nil
	u.Host = name + ".webxapp.io"
	config, err := websocket.NewConfig(u.String(), u.String())
	if err != nil {
		log.Fatal(err)
	}

	t := time.Now()

	c, err := wsDial(addr, config)
	for err != nil {
		time.Sleep(Timeout / 10)
		c, err = wsDial(addr, config)
		if time.Since(t) > Timeout {
			log.Fatal("timeout")
		}
	}
	var wg sync.WaitGroup
	wg.Add(2)
	go ioCopy(c, os.Stdin, &wg)
	go ioCopy(os.Stdout, c, &wg)
	wg.Wait()
}

func wsDial(addr string, config *websocket.Config) (*websocket.Conn, error) {
	rwc, err := net.Dial("tcp", addr)
	if err != nil {
		return nil, err
	}
	return websocket.NewClient(config, rwc)
}

func ioCopy(w io.Writer, r io.Reader, wg *sync.WaitGroup) {
	_, err := io.Copy(w, r)
	if err != nil {
		log.Println(err)
	}
	wg.Done()
}

func maybePrintInfo() {
	if os.Getenv("HKPLUGINMODE") == "info" {
		fmt.Println(strings.TrimSpace(usage) + "\n\n" + strings.TrimSpace(help))
		os.Exit(0)
	}
}

const (
	usage = `
runx 0: run a unix command in a dyno
`

	help = `
Usage: hk runx [-d] [command] [arguments]

Command runx runs a Unix command in a dyno.

The dyno's I/O is connected to local stdin and stdout.

If flag -d is given, the command runs "detached". The dyno
takes stdin from /dev/null and sends stdout to the app log.
`
)
