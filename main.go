// Command runx is an hk plugin to run a command on Heroku.
// It's like heroku run, but doesn't use the rendezvous
// service, instead using a standard HTTP router, webx.
package main

import (
	"bytes"
	"code.google.com/p/go.net/websocket"
	"encoding/json"
	"fmt"
	"github.com/kr/pty"
	"io"
	"io/ioutil"
	"net/url"
	//"net/http/httputil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"
)

const Timeout = 10 * time.Second

const script = `
echo start;
set -e;
curl -so /tmp/runxd https://frozen-citadel-4101.herokuapp.com/bin/runxd
chmod +x /tmp/runxd;
echo ready;
exec /tmp/runxd;
`

var attached = true

func main() {
	log.SetFlags(0)
	maybePrintInfo()
	args := os.Args[1:]
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, strings.TrimSpace(help))
		os.Exit(2)
	}
	if args[0] == "-d" {
		attached = false
		args = args[1:]
	}

	if !attached {
		err := herokuRun(strings.Join(args, " "), nil)
		if err != nil {
			log.Fatal(err)
		}
	}

	rows, cols, err := pty.Getsize(os.Stdin)
	if err != nil {
		rows, cols = 24, 80
	}
	runxURL, err := getToken()
	if err != nil {
		log.Fatal(err)
	}

	env := map[string]string{
		"RUNX_URL": runxURL,
	}
	err = herokuRun(script, env)
	if err != nil {
		log.Fatal(err)
	}
	log.Fatal(execSSH(runxURL, args))
}

// Uses hk api to send a ps run request.
func herokuRun(cmd string, env map[string]string) error {
	// as far as the platform is concerned,
	// the dyno is always detached.
	params := map[string]interface{}{"command": cmd}
	if env != nil {
		params["env"] = env
	}
	b, err := json.Marshal(params)
	if err != nil {
		return err
	}
	apiURL := strings.TrimRight(os.Getenv("HEROKU_API_URL"), "/")
	app := os.Getenv("HKAPP")
	req, err := http.NewRequest("POST", apiURL+"/apps/"+app+"/dynos", bytes.NewReader(b))
	if err != nil {
		return err
	}
	req.SetBasicAuth(os.Getenv("HKUSER"), os.Getenv("HKPASS"))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/vnd.heroku+json; version=3")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 201 {
		return fmt.Errorf("run: unexpected http status: %s", resp.Status)
	}
	return nil
}

func execSSH(url string, args []string) error {
	argv := []string{
		"ssh",
		"-oProxyCommand=#{rendezvous} #{hostname}",
		"-oStrictHostKeyChecking=no",
		"-oUserKnownHostsFile=/dev/null",
		"dyno@#{hostname}",
	}
	return syscall.Exec("/usr/bin/ssh", append(argv, args), nil)
}

// getToken returns a rendezvous token from the webx api.
// It's like provisioning a normal addon resource, except:
//   - no privileges are necessary; anyone can get one
//   - the name is generated by the webx api
//   - webx keeps no persistent state (e.g. custom domains)
func getToken() (string, error) {
	resp, err := http.Get("https://api.webx.io/rendezvous-token")
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 201 {
		return "", fmt.Errorf("token: unexpected http status: %s", resp.Status)
	}
	b, err := ioutil.ReadAll(resp.Body)
	return string(b), err
}

func maybePrintInfo() {
	if os.Getenv("HKPLUGINMODE") == "info" {
		fmt.Println(strings.TrimSpace(usage) + "\n\n" + strings.TrimSpace(help))
		os.Exit(0)
	}
}

const (
	usage = `
runx 0: run a unix command in a dyno
`

	help = `
Usage: hk runx [-d] command [arguments]

Command runx runs a Unix command in a dyno.

The dyno's I/O is connected to local stdin and stdout.

If flag -d is given, the command runs "detached". The dyno
takes stdin from /dev/null and sends stdout to the app log.
`
)
