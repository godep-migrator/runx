// Command runx is an hk plugin to run a command on Heroku.
// It's like heroku run, but doesn't use the rendezvous
// service, instead using a standard HTTP router, webx.
package main

import (
	"bytes"
	"code.google.com/p/go.net/websocket"
	"encoding/json"
	"fmt"
	"github.com/kr/pty"
	"io"
	"io/ioutil"
	"net/url"
	//"net/http/httputil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"
)

const Timeout = 10 * time.Second

const script = `
echo start;
set -e;
curl -so /tmp/runxd https://frozen-citadel-4101.herokuapp.com/bin/runxd
chmod +x /tmp/runxd;
echo ready;
exec /tmp/runxd;
`

var attached = true

func main() {
	log.SetFlags(0)
	maybePrintInfo()
	args := os.Args[1:]
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, strings.TrimSpace(help))
		os.Exit(2)
	}
	if args[0] == "-d" {
		attached = false
		args = args[1:]
	}

	if !attached {
		err := herokuRun(strings.Join(args, " "), nil)
		if err != nil {
			log.Fatal(err)
		}
	}

	rows, cols, err := pty.Getsize(os.Stdin)
	if err != nil {
		rows, cols = 24, 80
	}
	runxURL, err := getToken()
	if err != nil {
		log.Fatal(err)
	}
	env := map[string]string{
		"RUNX_URL": runxURL,
	}
	err = herokuRun(script, env)
	if err != nil {
		log.Fatal(err)
	}
	err = connectAndProxy(runxURL, args, []string{
		"LINES=" + strconv.Itoa(rows),
		"COLUMNS=" + strconv.Itoa(cols),
		"TERM=" + os.Getenv("TERM"),
	})
	if err != nil {
		log.Fatal(err)
	}
}

// Uses hk api to send a ps run request.
func herokuRun(cmd string, env map[string]string) error {
	// as far as the platform is concerned,
	// the dyno is always detached.
	params := map[string]interface{}{"command": cmd}
	if env != nil {
		params["env"] = env
	}
	b, err := json.Marshal(params)
	if err != nil {
		return err
	}
	apiURL := strings.TrimRight(os.Getenv("HEROKU_API_URL"), "/")
	app := os.Getenv("HKAPP")
	req, err := http.NewRequest("POST", apiURL+"/apps/"+app+"/dynos", bytes.NewReader(b))
	if err != nil {
		return err
	}
	req.SetBasicAuth(os.Getenv("HKUSER"), os.Getenv("HKPASS"))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/vnd.heroku+json; version=3")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 201 {
		return fmt.Errorf("run: unexpected http status: %s", resp.Status)
	}
	return nil
}

func connectAndProxy(urlStr string, args, env []string) error {
	params, err := json.Marshal(struct{ Args, Env []string }{args, env})
	if err != nil {
		return err
	}

	urlStr = strings.TrimRight("ws:"+urlStr[6:], "/") + "/run"
	u, err := url.Parse(urlStr)
	if err != nil {
		return err
	}
	name := u.User.Username()
	u.User = nil
	u.Host += ":80"
	u.Host = name + ".webxapp.io:80"
	config, err := websocket.NewConfig(u.String(), u.String())
	if err != nil {
		return err
	}
	config.Header.Set("Host", name+".webxapp.io")

	t := time.Now()
	c, err := websocket.DialConfig(config)
	for err != nil {
		time.Sleep(time.Second)
		c, err = websocket.DialConfig(config)
		if time.Since(t) > Timeout {
			log.Fatal("timeout")
		}
	}
	c.Write(params)

	if IsTerminal(os.Stdin) {
		err := MakeRaw(os.Stdin)
		if err != nil {
			return err
		}
		defer RestoreTerm(os.Stdin)
		sig := make(chan os.Signal, 1)
		signal.Notify(sig, os.Interrupt, os.Signal(syscall.SIGQUIT))
		go func() {
			defer RestoreTerm(os.Stdin)
			for n := range sig {
				switch n {
				case os.Interrupt:
					c.Write([]byte{3})
				case os.Signal(syscall.SIGQUIT):
					c.Write([]byte{28})
				}
			}
		}()
	}

	go io.Copy(c, os.Stdin)
	_, err = io.Copy(os.Stdout, c)
	return err
}

// getToken returns a rendezvous token from the webx api.
// It's like provisioning a normal addon resource, except:
//   - no privileges are necessary; anyone can get one
//   - the name is generated by the webx api
//   - webx keeps no persistent state (e.g. custom domains)
func getToken() (string, error) {
	resp, err := http.Get("https://api.webx.io/rendezvous-token")
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 201 {
		return "", fmt.Errorf("token: unexpected http status: %s", resp.Status)
	}
	b, err := ioutil.ReadAll(resp.Body)
	return string(b), err
}

func maybePrintInfo() {
	if os.Getenv("HKPLUGINMODE") == "info" {
		fmt.Println(strings.TrimSpace(usage) + "\n\n" + strings.TrimSpace(help))
		os.Exit(0)
	}
}

const (
	usage = `
runx 0: run a unix command in a dyno
`

	help = `
Usage: hk runx [-d] command [arguments]

Command runx runs a Unix command in a dyno.

The dyno's I/O is connected to local stdin and stdout.

If flag -d is given, the command runs "detached". The dyno
takes stdin from /dev/null and sends stdout to the app log.
`
)
